var mongoose = require('mongoose');
var http = require('http');
var Library = require('../server/libraries/libraryModel.js');
var zlib = require('zlib');
var Method = require('../server/methods/methodModel.js');
var bing = require('node-bing-api')({accKey: process.env.BING_ACCOUNT_KEY});
var _ = require('underscore');
var path = require('path');
// var async = require('async');

var QUESTIONS_PER_METHOD = 3;
var QUESTION_ID_REGEX = /stackoverflow.com\/questions\/(\d+)\//;

mongoose.connect('mongodb://localhost/flockdocs'); // connect to mongo database named flockdocs

var waitTime = 0;

Method.remove({}).exec().then(function(numRemoved) {
  console.log('Methods collection cleared. ' + numRemoved + ' documents removed.');

  Library.find().exec().then(function(libs) {
    // console.dir(libs);
    libs.forEach(function(lib) {
      //TODO scrape official library documentation URL for fresh methods??
      // console.dir(lib);
      lib.methods.forEach(function(method) {
        setTimeout(function() { getStackOverflowData(lib.name, method); }, waitTime);
        waitTime += 500;
        //TODO autogenerated question answers... - autogenerate questions?
      
        //followed by updating the data in the mongoDB..
      });
    });
  });
});

var getStackOverflowData = function(libraryName, method) {  
  bing.search('site:stackoverflow.com ' + libraryName + ' ' + method, function(error, res, body){
    // console.log("RES:");
    // console.log(res);
    // console.log("BODY");
    // console.log(body);
    if (error) {
      if(error.code === 'ETIMEDOUT') {
        console.log("TIMED OUT, TRYING AGAIN: " + libraryName + '|' + method);
        getStackOverflowData(libraryName, method);
      } else {
        console.error(error);
      }
      return;
    }

    var results = body.d.results;
    if(results.length > 0) {
      var questionIDs = [];
      for (var i = 0; i < results.length; i++) {
        var questionID = results[i].Url.match(QUESTION_ID_REGEX)[1];
        questionIDs.push(parseInt(questionID));
      }
      // console.log(libraryName + ' ' + method + ' ' + questionIDs);

      var options = {
        host:'api.stackexchange.com',
        path:'/2.2/questions/' + questionIDs.join(';') + '?pagesize=' + QUESTIONS_PER_METHOD + '&site=stackoverflow&key=ssNWU)nQZdqCIR3kXFf0IA((&filter=!-*f(6rkuau1P',
        headers: {
          'Accept-Encoding': 'gzip'
        }
      };
      // console.log(options.path);

      http.request(options,function(res) {
        var gzstream = zlib.createGunzip();
        res.pipe(gzstream);

        var json = '';
        gzstream.on('data',function(chunk) {
          json+= chunk;
        });

        gzstream.on('end', function() {
          // console.log(json);

          var data = JSON.parse(json);
          // console.log(data.items[0].body);
          // console.log(data.items[0].answers[0]);
          // console.dir(data.items[0]);

          //order questions by google search results order

          // console.log(questionIDs);
          // console.dir(data.items);
          var sortedQuestions = [];
          for(var i=0; i<questionIDs.length;i++) {
            sortedQuestions.push(_.find(data.items,function(item) {
              return item.question_id === questionIDs[i];
            }));
          }

          //order the answer arrays by score, and restrict them to the top 3 non-negative-scored answers
          data.items.forEach(function(item) {
            if(item.answers) {
              item.answers.sort(function(a,b) {
                if(a.score > b.score) {
                  return -1;
                } else if (b.score < a.score) {
                  return 1;
                } else {
                  return 0;
                }
              });

              item.answers = item.answers.slice(0,3);
              for (var i = item.answers.length - 1; i >= 0; i--) {
                if(item.answers[i].score < 0) {
                  item.answers.pop();
                }
              }
            }
          });


          if(data.items.length) {
            Method.create({name: method, library: libraryName, topQuestions: data.items}).then(function(doc,err) {
              console.log("Successfully loaded: " + libraryName + '|' + method + '|' + sortedQuestions.join(';') + '|' + data.quota_remaining);
              if(err){
                console.dir(err);
              }
            });
          }
        });
      }).end();
    }
  },
  {
    top: QUESTIONS_PER_METHOD // Number of results (max 50)
  });
};
